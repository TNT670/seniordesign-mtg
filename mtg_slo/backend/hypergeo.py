"""
Code for the function findLandCombos toward the end of this file was converted
and modified from Java code retrieved from
https://algorithms.tutorialhorizon.com/find-all-unique-combinations-of-exact-k-numbers-from-1-to-9-with-sum-to-n/
"""

from math import factorial
import itertools


# n! / [k!(n-k)!] for (n choose k)
def binom(n,k):
	# print(n,k,n-k)
	return factorial(n) / ( factorial(k) * factorial(n-k) )


def LsHeuristic(manaCosts: list, numLandsNeeded = 17):
    """ Returns a list representing the land set. Rounds up; the returned list
        should add up to either 17 or 18.
    
    Keyword Arguments:
        manaCosts: list of mana costs of the form (generic, (W,U,B,R,G)).
        numLandsNeeded: Total number of lands needed to complete the deck
    
    Example:
        manaCosts = [(2, (0,0,0,1,1)), (2, (0,0,0,1,0)), (2, (0,0,0,0,1)),
                     (1, (0,0,0,1,0)), (0, (0,0,0,1,1)), (1, (0,0,0,0,1)),
                     (0, (0,0,0,1,0)), (0, (0,0,0,0,1))]
        landSet = [0, 0, 0, 9, 9]
    """
    
    

    lands = [0,0,0,0,0]
    for elem in manaCosts:
        lands = [lands[i] + elem[1][i] for i in range(5)]
    landSet = [round(x * numLandsNeeded / sum(lands)) for x in lands]
    
    if sum(landSet) != numLandsNeeded:
    	raise ValueError('Wrong number of lands generated by LsHeuristic: '+str(numLandsNeeded)+' expected, got: '+str(sum(landSet)),landSet)
    
    return landSet


def MVHG(pop,req,totalPop):
    """ Returns probability

    Keyword Arguments:
        pop:(number of lands) iterable of subpopulation counts
        req:(mana cost) iterable of subpopulation requests
        totalPop:(size of deck) total number of objects in population. Can be >sum(pop)

    Example:
        pop = (10, 7)
        req = (2, 2)
        totalPop = 40
    """
    sampleSize = sum(req) + 7
    
    num = 1
    for N,k in zip(pop,req):
        
        # If N is ever < k, we are looking to pull more marbles
        # out of the bag than are in it. The total odds is zero, since
        # this will never occur, even if the other classes are satisfied.
        if N < k: 
            return 0

        num *= binom(N,k)

    num *= binom(totalPop - sum(pop), 7)
    
    den = binom(totalPop,sampleSize)
    # print(num)
    # print(den)
    return num / den


def cardCastibility(landSet:list, manaCost:tuple):
    """ Returns odds of being able to cast a card on curve. This function
        assumes that the mana cost of a card is less than the number of lands of
        the corresponding color(s) required. May need to update this function
        later.

    Keyword Arguments:
        landSet: tuple of lands. Of form (W,U,B,R,G), with 0 for no lands
                (0,0,0,10,7) would represent a set of lands of 10 Mountain 7 Forest
        
        manaCost: tuple of mana cost (generic, (W,U,B,R,G))
    """
    
    # Example: For 2RG, each of these casts. Programmatically find set
    # (3,1) rrrg
    # (2,2) rrgg
    # (1,3) rggg
    # print(landSet,type(landSet))
    lands = landSet.copy()
    res = [0, 0, 0, 0, 0]
    for i in range(len(res)):
        lands[i] -= manaCost[1][i]
        if (lands[i] < 0):
            return 0
        res[i] += manaCost[1][i]
    combos = []
    # This is where the magic happens
    findManaCombos(manaCost[0], lands, res, combos)
    manacombinations = set(combos)
    
    odds = 0
    for c in manacombinations:
        odds += MVHG(landSet, c, 40)
    
    return odds


def deckCastibility(manaCosts: list, lands: list):
	# Returns average castibility of spells in deck.

	dC = 0
	for m in manaCosts:
		c = cardCastibility(lands, m)
		dC += c
	
	dC /= len(lands)
	
	return dC


def findManaCombos(generics, lands, res, combos):
    if (generics == 0):
        combos += (tuple(res),)
        return
    for i in range(len(res)):
        if (lands[i] != 0):
            landsCopy = lands.copy()
            landsCopy[i] -= 1
            resCopy = res.copy()
            resCopy[i] += 1
            findManaCombos(generics - 1, landsCopy, resCopy, combos)


def bestLands(manaCosts: list, numLandsNeeded, debug: bool):
    # Returns the optimal number of lands for the given list of mana costs for
    # spells.
    
    initLandSet = LsHeuristic(manaCosts)
    if debug: print('LsHeuristic landSet: ',initLandSet)
    
    # Number of colors this deck uses
    numColors = sum([1 for c in initLandSet if c!=0])
    

    # If the deck only has one color, we do not need to search.
    if numColors == 1:
        return initLandSet
    

    # Recursive, in-place function to find some number of numColor-tuples,
    # where each sums to 17. 2 color example [ [0,17]-->[8,9] ]
    res = []
    landCombos = []
    findLandCombos(17, numColors, 0, 0, landCombos, res)
    

    # Get full set of landCombos by permuting and removing duplicates
    # 2 color example [ [0,17]-->[17,0] ]
    allLandCombos = []
    for ls in landCombos:
        allLandCombos += list(itertools.permutations(ls))
    allLandCombos = sorted(list(set(allLandCombos)))


    # Expand numColor-tuples into proper 5-tuples of lands
    # 2 color example [ [0,0,0,0,17]-->[0,0,0,17,0] ]
    landSets = []
    for lc in allLandCombos:
        thisLandCombo = [0, 0, 0, 0, 0]
        j = 0
        for i in range(len(thisLandCombo)):
            if initLandSet[i] != 0:
                thisLandCombo[i] = lc[j]
                j += 1
        landSets += [thisLandCombo]
    if debug:
        print('Initial landSets')
        printListOfLandSets(landSets)
    
    # Drop landSets that make any card in our deck uncastable
    maxReqs=[]
    for c in range(5):
    	maxReqs += [max([x[1][c] for x in manaCosts])]
    
    if debug: print('landSet minimums to cast every card\n',maxReqs,'\n',sep='')
    
    badLS = []
    for i,landSet in enumerate(landSets):
        for c in range(5): # for each color in the 5-tuple
            if landSet[c] < maxReqs[c]:
                badLS += [landSets[i][:]]
                landSets[i] = 0
                break # if one minimum not satisfied, whole lS is not satisfied
    landSets = list(filter(lambda x:x!=0,landSets))
    if debug:
        print('dropped', len(badLS),'uncastable landSets like')
        if len(badLS)!=0: print(badLS[len(badLS)//2],'\n')
        # printListOfLandSets(badLS)
        print('good post cast-filter landSets:')
        printListOfLandSets(landSets)
        exit()
    
    


    # print('\nlandSets to search on:\n',landSets)
    
    # Init search with heuristic case
    bestScore = deckCastibility(manaCosts, initLandSet)
    bestLandSet = initLandSet.copy()

    for thisLandCombo in landSets:
        thisDC = deckCastibility(manaCosts, thisLandCombo)
        if (thisDC > bestScore):
            bestLandSet = thisLandCombo
            bestScore = thisDC
        print(thisLandCombo,'\t',thisDC)
    print('\nBest ', bestLandSet, bestScore)
    return bestLandSet


def findLandCombos(n, k, total, start, landCombos, res):
    if (k == 0):
        if (total == n):
            landCombos += [res]
        return
    
    for i in range(start, n+1):
        res += [i]
        findLandCombos(n, k - 1, total + i, i, landCombos, res.copy())
        del res[-1]


def printListOfLandSets(theList:list, mode = 'row'):
    """ Given a list of landSets, print them in a way that
        is easier to comprehend than directly printing a list
        of many 5-tuples.

    Keyword Arguments:
        theList: list
            A list of lists/tuple. Each sublist is has five elements,
            and represents a landSet.
        mode: str
            Argument to determine what formatting of output to use.
                'row': Default value, concise single row format. [2-12, 2-12, 0, 0, 3-12]
                'col': Pretty print. Uses more lines for readability.

    """
    maxs = [-1]*5
    mins = [1000]*5
    for thisLS in theList:
        for i,c in enumerate(thisLS):
            if c < mins[i]:
                mins[i] = c
            elif c > maxs[i]:
                maxs[i] = c
    # print(mins,'\n',maxs,end='')
    
    minMaxs = [(n,x) for n,x in zip(mins,maxs)]
    # print(minMaxs)

    strMinMaxs = []
    for i,(n,x) in enumerate(minMaxs):
        s = str(n)+'-'+str(x)
        if n==0 and x==0:
            s = '0'
        if i != len(minMaxs)-1:
            s+=', '
        strMinMaxs += [s]
    
    if mode == 'row':
        print(len(theList),' landSets: ','[',''.join(strMinMaxs),']',sep='')
    
    elif mode == 'col':
        c = ['W','U','B','R','G']
        print(len(theList),'landSets given. Value ranges:')
        for i in range(len(strMinMaxs)):
            print('\t',c[i],'\t',strMinMaxs[i])
    else:
        raise ValueError("Unknown print-mode requested: '"+mode+"'")

    print()
    return




if __name__ == '__main__':
    p = (5,10,15)
    r = (2,2,2)
    N = 30
    n = 6
    print('execute parse_json as main to test')
    # print(list(itertools.permutations([0,1,17])))
    #assert round(MVHG(p,r,N,n),10) == 0.0795755968
    # Example per
    # https://en.wikipedia.org/wiki/Hypergeometric_distribution#Multivariate_hypergeometric_distribution

    # cardCastibility((0,0,0,10,7),('2RG'))
